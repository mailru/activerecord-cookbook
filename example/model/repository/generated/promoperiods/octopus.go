// Code generated by argen. DO NOT EDIT.
// This code was generated from a template.
//
// Manual changes to this file may cause unexpected behavior in your application.
// Manual changes to this file will be overwritten if the code is regenerated.
//
// Generate info: argen@v1.11.0-b (Commit: 6934fae2)
package promoperiods

import (
	"bytes"
	"context"
	"fmt"
	"log"
	"time"

	"strings"

	"github.com/mailru/activerecord-cookbook/example/model/dictionary"
	"github.com/mailru/activerecord-cookbook/example/model/repository/generated/arobj"
	triggerRepairTuple "github.com/mailru/activerecord-cookbook/example/model/repository/repair"
	serializerProduct "github.com/mailru/activerecord-cookbook/example/model/serializer"
	"github.com/mailru/activerecord/pkg/activerecord"
	"github.com/mailru/activerecord/pkg/iproto/iproto"
	"github.com/mailru/activerecord/pkg/octopus"
	serializerJSON "github.com/mailru/activerecord/pkg/serializer"
)

type Promoperiods struct {
	octopus.BaseField
	fieldID         string
	fieldCode       string
	fieldEmail      string
	fieldStart      int32
	fieldFinish     *dictionary.Product
	fieldAction     string
	fieldPlatform   map[string]interface{}
	fieldPromobunch uint32
	fieldPlatforms  uint32
	fieldPlanID     int32
	fieldPlanType   string
	fieldPrice      float64
}

type PromoperiodsList []*Promoperiods

const (
	namespace            uint32 = 6
	cntFields            uint32 = 12
	PlatformswebFlag            = 1 << 0
	PlatformsiosFlag            = 1 << 1
	PlatformsandroidFlag        = 1 << 2
	PlatformshuaweiFlag         = 1 << 3
)

var defaultValue = [][]byte{
	octopus.PackString([]byte{}, "", iproto.ModeDefault),
	octopus.PackString([]byte{}, "", iproto.ModeDefault),
	octopus.PackString([]byte{}, "", iproto.ModeDefault),
	iproto.PackUint32([]byte{}, 0, iproto.ModeDefault),
	iproto.PackUint64([]byte{}, 0, iproto.ModeDefault),
	octopus.PackString([]byte{}, "", iproto.ModeDefault),
	octopus.PackString([]byte{}, "", iproto.ModeDefault),
	iproto.PackUint32([]byte{}, 0, iproto.ModeDefault),
	iproto.PackUint32([]byte{}, 0, iproto.ModeDefault),
	iproto.PackUint32([]byte{}, 0, iproto.ModeDefault),
	octopus.PackString([]byte{}, "", iproto.ModeDefault),
	octopus.PackString([]byte{}, "", iproto.ModeDefault)}

var boxOption, _ = octopus.NewOptions(
	"127.0.0.1:11011",
	octopus.ModeMaster,
	octopus.WithTimeout(time.Millisecond*500, time.Millisecond*500),
)

var clusterInfo = activerecord.NewClusterInfo(
	activerecord.WithShard([]activerecord.OptionInterface{boxOption}, []activerecord.OptionInterface{}),
)

func New(ctx context.Context) *Promoperiods {
	newObj := Promoperiods{}
	newObj.BaseField.UpdateOps = []octopus.Ops{}
	newObj.BaseField.ExtraFields = [][]byte{}
	newObj.BaseField.Objects = map[string][]octopus.ModelStruct{}

	return &newObj
}
func repairTuple(ctx context.Context, tuple *octopus.TupleData) error {
	logger := activerecord.Logger()

	logger.Debug(ctx, "Promoperiods", "Repair trigger called")

	err := triggerRepairTuple.Promoperiod(tuple, cntFields)
	if err != nil {
		return fmt.Errorf("trigger can't repair tuple %w", err)
	}

	return nil
}

func TupleToStruct(ctx context.Context, tuple octopus.TupleData) (*Promoperiods, error) {
	np := New(ctx)

	valID, err := UnpackID(bytes.NewReader(tuple.Data[0]))
	if err != nil {
		return nil, err
	}

	np.SetID(valID)
	valCode, err := UnpackCode(bytes.NewReader(tuple.Data[1]))
	if err != nil {
		return nil, err
	}

	np.SetCode(valCode)
	valEmail, err := UnpackEmail(bytes.NewReader(tuple.Data[2]))
	if err != nil {
		return nil, err
	}

	np.SetEmail(valEmail)
	valStart, err := UnpackStart(bytes.NewReader(tuple.Data[3]))
	if err != nil {
		return nil, err
	}

	np.SetStart(valStart)
	valFinish, err := UnpackFinish(bytes.NewReader(tuple.Data[4]))
	if err != nil {
		return nil, err
	}

	np.SetFinish(valFinish)
	valAction, err := UnpackAction(bytes.NewReader(tuple.Data[5]))
	if err != nil {
		return nil, err
	}

	np.SetAction(valAction)
	valPlatform, err := UnpackPlatform(bytes.NewReader(tuple.Data[6]))
	if err != nil {
		return nil, err
	}

	np.SetPlatform(valPlatform)
	valPromobunch, err := UnpackPromobunch(bytes.NewReader(tuple.Data[7]))
	if err != nil {
		return nil, err
	}

	np.SetPromobunch(valPromobunch)
	valPlatforms, err := UnpackPlatforms(bytes.NewReader(tuple.Data[8]))
	if err != nil {
		return nil, err
	}

	np.SetPlatforms(valPlatforms)
	valPlanID, err := UnpackPlanID(bytes.NewReader(tuple.Data[9]))
	if err != nil {
		return nil, err
	}

	np.SetPlanID(valPlanID)
	valPlanType, err := UnpackPlanType(bytes.NewReader(tuple.Data[10]))
	if err != nil {
		return nil, err
	}

	np.SetPlanType(valPlanType)
	valPrice, err := UnpackPrice(bytes.NewReader(tuple.Data[11]))
	if err != nil {
		return nil, err
	}

	np.SetPrice(valPrice)

	np.BaseField.Exists = true
	np.BaseField.UpdateOps = []octopus.Ops{}

	if tuple.Cnt > cntFields {
		logger := activerecord.Logger()

		logger.Warn(ctx, "Promoperiods", np.PrimaryString(), "Extra fields")

		np.BaseField.ExtraFields = tuple.Data[cntFields:]
	}

	return np, nil
}

func NewFromBox(ctx context.Context, tuples []octopus.TupleData) ([]*Promoperiods, error) {
	logger := activerecord.Logger()

	logger.Debug(ctx, "Promoperiods", fmt.Sprintf("Cnt tuples %d", len(tuples)))

	ret := make([]*Promoperiods, 0, len(tuples))

	for num, tuple := range tuples {
		var repaired bool

		if tuple.Cnt != cntFields {
			err := repairTuple(ctx, &tuple)
			if err != nil {
				logger.Error(ctx, "Promoperiods", fmt.Errorf("%d tuple in response has %d fields but expected: %d. Repair fault: %w", num, tuple.Cnt, cntFields, err))
				continue
			}

			repaired = true
		}

		if tuple.Cnt < cntFields {
			return nil, fmt.Errorf("not enought selected fields %d in response tuple: %d but expected %d fields", tuple.Cnt, num, cntFields)
		}

		np, err := TupleToStruct(ctx, tuple)
		if err != nil {
			logger.Warn(ctx, "Promoperiods", fmt.Sprintf("error unpack tuple %s. Try to repair", err))

			err = repairTuple(ctx, &tuple)
			if err != nil {
				logger.Error(ctx, "Promoperiods", fmt.Sprintf("can't repair: %s", err))
				continue
			}

			repaired = true

			np, err = TupleToStruct(ctx, tuple)
		}
		if err != nil {
			logger.Error(ctx, "Promoperiods", fmt.Sprintf("error unpack tuple %s", err))
			return nil, err
		}

		np.BaseField.Repaired = repaired
		ret = append(ret, np)
	}

	return ret, nil
}
func packID(w []byte, ID string) ([]byte, error) {
	pvar := ID

	return octopus.PackString(w, pvar, iproto.ModeDefault), nil
}

func UnpackID(r *bytes.Reader) (ret string, errRet error) {
	var ID string

	err := octopus.UnpackString(r, &ID, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field ID in tuple: '%w'", err)
		return
	}

	bvar := ID

	svar := bvar

	return svar, nil
}

func (obj *Promoperiods) GetID() string {
	return obj.fieldID
}

func (obj *Promoperiods) SetID(ID string) error {
	if obj.BaseField.Exists {
		return fmt.Errorf("can't modify field included in primary key")
	}

	data, err := packID([]byte{}, ID)
	if err != nil {
		return err
	}

	if len(data) > 36 {
		return fmt.Errorf("max length of field 'Promoperiods.ID' is '%d' (received '%d')", 36, len(data))
	}

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 0, Op: octopus.OpSet, Value: data})
	obj.fieldID = ID

	return nil
}

func packCode(w []byte, Code string) ([]byte, error) {
	pvar := Code

	return octopus.PackString(w, pvar, iproto.ModeDefault), nil
}

func UnpackCode(r *bytes.Reader) (ret string, errRet error) {
	var Code string

	err := octopus.UnpackString(r, &Code, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field Code in tuple: '%w'", err)
		return
	}

	bvar := Code

	svar := bvar

	return svar, nil
}

func (obj *Promoperiods) GetCode() string {
	return obj.fieldCode
}

func (obj *Promoperiods) SetCode(Code string) error {
	data, err := packCode([]byte{}, Code)
	if err != nil {
		return err
	}

	if len(data) > 128 {
		return fmt.Errorf("max length of field 'Promoperiods.Code' is '%d' (received '%d')", 128, len(data))
	}

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 1, Op: octopus.OpSet, Value: data})
	obj.fieldCode = Code

	return nil
}

func packEmail(w []byte, Email string) ([]byte, error) {
	pvar := Email

	return octopus.PackString(w, pvar, iproto.ModeDefault), nil
}

func UnpackEmail(r *bytes.Reader) (ret string, errRet error) {
	var Email string

	err := octopus.UnpackString(r, &Email, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field Email in tuple: '%w'", err)
		return
	}

	bvar := Email

	svar := bvar

	return svar, nil
}

func (obj *Promoperiods) GetEmail() string {
	return obj.fieldEmail
}

func (obj *Promoperiods) SetEmail(Email string) error {
	data, err := packEmail([]byte{}, Email)
	if err != nil {
		return err
	}

	if len(data) > 256 {
		return fmt.Errorf("max length of field 'Promoperiods.Email' is '%d' (received '%d')", 256, len(data))
	}

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 2, Op: octopus.OpSet, Value: data})
	obj.fieldEmail = Email

	return nil
}

func packStart(w []byte, Start int32) ([]byte, error) {
	pvar := uint32(Start)

	return iproto.PackUint32(w, pvar, iproto.ModeDefault), nil
}

func UnpackStart(r *bytes.Reader) (ret int32, errRet error) {
	var Start uint32

	err := iproto.UnpackUint32(r, &Start, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field Start in tuple: '%w'", err)
		return
	}

	bvar := int32(Start)

	svar := bvar

	return svar, nil
}

func (obj *Promoperiods) GetStart() int32 {
	return obj.fieldStart
}

func (obj *Promoperiods) SetStart(Start int32) error {
	data, err := packStart([]byte{}, Start)
	if err != nil {
		return err
	}

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 3, Op: octopus.OpSet, Value: data})
	obj.fieldStart = Start

	return nil
}

func MarshalFinish(Finish *dictionary.Product) (any, error) {
	pvar, err := serializerProduct.ProductMarshal(Finish)
	if err != nil {
		return nil, fmt.Errorf("error marshal field Finish: %w", err)
	}

	return pvar, nil
}

func packFinish(w []byte, Finish *dictionary.Product) ([]byte, error) {
	pvar, err := serializerProduct.ProductMarshal(Finish)
	if err != nil {
		return nil, fmt.Errorf("error marshal field Finish: %w", err)
	}

	return iproto.PackUint64(w, pvar, iproto.ModeDefault), nil
}

func UnpackFinish(r *bytes.Reader) (ret *dictionary.Product, errRet error) {
	var Finish uint64

	err := iproto.UnpackUint64(r, &Finish, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field Finish in tuple: '%w'", err)
		return
	}

	bvar := Finish

	var svar dictionary.Product

	err = serializerProduct.ProductUnmarshal(bvar, &svar)
	if err != nil {
		errRet = fmt.Errorf("error unmarshal field Finish: %w", err)
		return
	}

	return &svar, nil
}

func (obj *Promoperiods) GetFinish() *dictionary.Product {
	return obj.fieldFinish
}

func (obj *Promoperiods) SetFinish(Finish *dictionary.Product) error {
	data, err := packFinish([]byte{}, Finish)
	if err != nil {
		return err
	}

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 4, Op: octopus.OpSet, Value: data})
	obj.fieldFinish = Finish

	return nil
}

func packAction(w []byte, Action string) ([]byte, error) {
	pvar := Action

	return octopus.PackString(w, pvar, iproto.ModeDefault), nil
}

func UnpackAction(r *bytes.Reader) (ret string, errRet error) {
	var Action string

	err := octopus.UnpackString(r, &Action, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field Action in tuple: '%w'", err)
		return
	}

	bvar := Action

	svar := bvar

	return svar, nil
}

func (obj *Promoperiods) GetAction() string {
	return obj.fieldAction
}

func (obj *Promoperiods) SetAction(Action string) error {
	data, err := packAction([]byte{}, Action)
	if err != nil {
		return err
	}

	logger := activerecord.Logger()

	logger.Warn(context.TODO(), "Promoperiods", obj.PrimaryString(), fmt.Sprintf("Size for field 'Action' not set. Cur field size: %d. Object: 'Promoperiods'", len(data)))

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 5, Op: octopus.OpSet, Value: data})
	obj.fieldAction = Action

	return nil
}

func MarshalPlatform(Platform map[string]interface{}) (any, error) {
	pvar, err := serializerJSON.JSONMarshal(Platform)
	if err != nil {
		return nil, fmt.Errorf("error marshal field Platform: %w", err)
	}

	return pvar, nil
}

func packPlatform(w []byte, Platform map[string]interface{}) ([]byte, error) {
	pvar, err := serializerJSON.JSONMarshal(Platform)
	if err != nil {
		return nil, fmt.Errorf("error marshal field Platform: %w", err)
	}

	return octopus.PackString(w, pvar, iproto.ModeDefault), nil
}

func UnpackPlatform(r *bytes.Reader) (ret map[string]interface{}, errRet error) {
	var Platform string

	err := octopus.UnpackString(r, &Platform, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field Platform in tuple: '%w'", err)
		return
	}

	bvar := Platform

	var svar map[string]interface{}

	err = serializerJSON.JSONUnmarshal(bvar, &svar)
	if err != nil {
		errRet = fmt.Errorf("error unmarshal field Platform: %w", err)
		return
	}

	return svar, nil
}

func (obj *Promoperiods) GetPlatform() map[string]interface{} {
	return obj.fieldPlatform
}

func (obj *Promoperiods) SetPlatform(Platform map[string]interface{}) error {
	data, err := packPlatform([]byte{}, Platform)
	if err != nil {
		return err
	}

	if len(data) > 64 {
		return fmt.Errorf("max length of field 'Promoperiods.Platform' is '%d' (received '%d')", 64, len(data))
	}

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 6, Op: octopus.OpSet, Value: data})
	obj.fieldPlatform = Platform

	return nil
}

func packPromobunch(w []byte, Promobunch uint32) ([]byte, error) {
	pvar := Promobunch

	return iproto.PackUint32(w, pvar, iproto.ModeDefault), nil
}

func UnpackPromobunch(r *bytes.Reader) (ret uint32, errRet error) {
	var Promobunch uint32

	err := iproto.UnpackUint32(r, &Promobunch, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field Promobunch in tuple: '%w'", err)
		return
	}

	bvar := Promobunch

	svar := bvar

	return svar, nil
}

func (obj *Promoperiods) GetPromobunch() uint32 {
	return obj.fieldPromobunch
}

func (obj *Promoperiods) SetPromobunch(Promobunch uint32) error {
	data, err := packPromobunch([]byte{}, Promobunch)
	if err != nil {
		return err
	}

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 7, Op: octopus.OpSet, Value: data})

	obj.fieldPromobunch = Promobunch

	return nil
}

func (obj *Promoperiods) SetBitPromobunch(mutArg uint32) error {
	if mutArg == 0 || obj.fieldPromobunch|mutArg == obj.fieldPromobunch {
		return nil
	}

	data := iproto.PackUint32([]byte{}, uint32(mutArg), iproto.ModeDefault)

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 7, Op: octopus.OpOr, Value: data})
	obj.fieldPromobunch |= mutArg

	return nil
}

func (obj *Promoperiods) ClearBitPromobunch(mutArg uint32) error {
	if mutArg == 0 || obj.fieldPromobunch & ^mutArg == obj.fieldPromobunch {
		return nil
	}

	data := iproto.PackUint32([]byte{}, uint32(^mutArg), iproto.ModeDefault)

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 7, Op: octopus.OpAnd, Value: data})
	obj.fieldPromobunch &= ^mutArg

	return nil
}

func packPlatforms(w []byte, Platforms uint32) ([]byte, error) {
	pvar := Platforms

	return iproto.PackUint32(w, pvar, iproto.ModeDefault), nil
}

func UnpackPlatforms(r *bytes.Reader) (ret uint32, errRet error) {
	var Platforms uint32

	err := iproto.UnpackUint32(r, &Platforms, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field Platforms in tuple: '%w'", err)
		return
	}

	bvar := Platforms

	svar := bvar

	return svar, nil
}

func (obj *Promoperiods) GetPlatforms() uint32 {
	return obj.fieldPlatforms
}

func (obj *Promoperiods) SetPlatforms(Platforms uint32) error {
	data, err := packPlatforms([]byte{}, Platforms)
	if err != nil {
		return err
	}

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 8, Op: octopus.OpSet, Value: data})

	obj.fieldPlatforms = Platforms

	return nil
}

func (obj *Promoperiods) SetBitPlatforms(mutArg uint32) error {
	if mutArg == 0 || obj.fieldPlatforms|mutArg == obj.fieldPlatforms {
		return nil
	}

	data := iproto.PackUint32([]byte{}, uint32(mutArg), iproto.ModeDefault)

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 8, Op: octopus.OpOr, Value: data})
	obj.fieldPlatforms |= mutArg

	return nil
}

func (obj *Promoperiods) ClearBitPlatforms(mutArg uint32) error {
	if mutArg == 0 || obj.fieldPlatforms & ^mutArg == obj.fieldPlatforms {
		return nil
	}

	data := iproto.PackUint32([]byte{}, uint32(^mutArg), iproto.ModeDefault)

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 8, Op: octopus.OpAnd, Value: data})
	obj.fieldPlatforms &= ^mutArg

	return nil
}

func (obj *Promoperiods) SetPlatformsweb() error {
	return obj.SetBitPlatforms(PlatformswebFlag)
}

func (obj *Promoperiods) ClearPlatformsweb() error {
	return obj.ClearBitPlatforms(PlatformswebFlag)
}

func (obj *Promoperiods) IsPlatformsweb() bool {
	return obj.GetPlatforms()&PlatformswebFlag == PlatformswebFlag
}

func (obj *Promoperiods) SetPlatformsios() error {
	return obj.SetBitPlatforms(PlatformsiosFlag)
}

func (obj *Promoperiods) ClearPlatformsios() error {
	return obj.ClearBitPlatforms(PlatformsiosFlag)
}

func (obj *Promoperiods) IsPlatformsios() bool {
	return obj.GetPlatforms()&PlatformsiosFlag == PlatformsiosFlag
}

func (obj *Promoperiods) SetPlatformsandroid() error {
	return obj.SetBitPlatforms(PlatformsandroidFlag)
}

func (obj *Promoperiods) ClearPlatformsandroid() error {
	return obj.ClearBitPlatforms(PlatformsandroidFlag)
}

func (obj *Promoperiods) IsPlatformsandroid() bool {
	return obj.GetPlatforms()&PlatformsandroidFlag == PlatformsandroidFlag
}

func (obj *Promoperiods) SetPlatformshuawei() error {
	return obj.SetBitPlatforms(PlatformshuaweiFlag)
}

func (obj *Promoperiods) ClearPlatformshuawei() error {
	return obj.ClearBitPlatforms(PlatformshuaweiFlag)
}

func (obj *Promoperiods) IsPlatformshuawei() bool {
	return obj.GetPlatforms()&PlatformshuaweiFlag == PlatformshuaweiFlag
}

func packPlanID(w []byte, PlanID int32) ([]byte, error) {
	pvar := uint32(PlanID)

	return iproto.PackUint32(w, pvar, iproto.ModeDefault), nil
}

func UnpackPlanID(r *bytes.Reader) (ret int32, errRet error) {
	var PlanID uint32

	err := iproto.UnpackUint32(r, &PlanID, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field PlanID in tuple: '%w'", err)
		return
	}

	bvar := int32(PlanID)

	svar := bvar

	return svar, nil
}

func (obj *Promoperiods) GetPlanID() int32 {
	return obj.fieldPlanID
}

func (obj *Promoperiods) SetPlanID(PlanID int32) error {
	data, err := packPlanID([]byte{}, PlanID)
	if err != nil {
		return err
	}

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 9, Op: octopus.OpSet, Value: data})
	obj.fieldPlanID = PlanID
	delete(obj.BaseField.Objects, "Plan")

	return nil
}

func packPlanType(w []byte, PlanType string) ([]byte, error) {
	pvar := PlanType

	return octopus.PackString(w, pvar, iproto.ModeDefault), nil
}

func UnpackPlanType(r *bytes.Reader) (ret string, errRet error) {
	var PlanType string

	err := octopus.UnpackString(r, &PlanType, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field PlanType in tuple: '%w'", err)
		return
	}

	bvar := PlanType

	svar := bvar

	return svar, nil
}

func (obj *Promoperiods) GetPlanType() string {
	return obj.fieldPlanType
}

func (obj *Promoperiods) SetPlanType(PlanType string) error {
	data, err := packPlanType([]byte{}, PlanType)
	if err != nil {
		return err
	}

	logger := activerecord.Logger()

	logger.Warn(context.TODO(), "Promoperiods", obj.PrimaryString(), fmt.Sprintf("Size for field 'PlanType' not set. Cur field size: %d. Object: 'Promoperiods'", len(data)))

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 10, Op: octopus.OpSet, Value: data})
	obj.fieldPlanType = PlanType
	delete(obj.BaseField.Objects, "Plans")

	return nil
}

func MarshalPrice(Price float64) (any, error) {
	pvar, err := serializerJSON.PrintfMarshal("%.2f", Price)
	if err != nil {
		return nil, fmt.Errorf("error marshal field Price: %w", err)
	}

	return pvar, nil
}

func packPrice(w []byte, Price float64) ([]byte, error) {
	pvar, err := serializerJSON.PrintfMarshal("%.2f", Price)
	if err != nil {
		return nil, fmt.Errorf("error marshal field Price: %w", err)
	}

	return octopus.PackString(w, pvar, iproto.ModeDefault), nil
}

func UnpackPrice(r *bytes.Reader) (ret float64, errRet error) {
	var Price string

	err := octopus.UnpackString(r, &Price, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field Price in tuple: '%w'", err)
		return
	}

	bvar := Price

	var svar float64

	err = serializerJSON.PrintfUnmarshal("%.2f", bvar, &svar)
	if err != nil {
		errRet = fmt.Errorf("error unmarshal field Price: %w", err)
		return
	}

	return svar, nil
}

func (obj *Promoperiods) GetPrice() float64 {
	return obj.fieldPrice
}

func (obj *Promoperiods) SetPrice(Price float64) error {
	data, err := packPrice([]byte{}, Price)
	if err != nil {
		return err
	}

	logger := activerecord.Logger()

	logger.Warn(context.TODO(), "Promoperiods", obj.PrimaryString(), fmt.Sprintf("Size for field 'Price' not set. Cur field size: %d. Object: 'Promoperiods'", len(data)))

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 11, Op: octopus.OpSet, Value: data})
	obj.fieldPrice = Price

	return nil
}

func selectBox(ctx context.Context, indexnum uint32, keysPacked [][][]byte, limiter activerecord.SelectorLimiter) ([]*Promoperiods, error) {
	logger := activerecord.Logger()
	ctx = logger.SetLoggerValueToContext(ctx, activerecord.ValueLogPrefix{"limiter": limiter.String()})
	metricTimer := activerecord.Metric().Timer("octopus", "Promoperiods")
	metricStatCnt := activerecord.Metric().StatCount("octopus", "Promoperiods")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "Promoperiods")

	w := octopus.PackSelect(namespace, indexnum, limiter.Offset(), limiter.Limit(), keysPacked)

	metricTimer.Timing(ctx, "select_pack")
	metricStatCnt.Inc(ctx, "select_keys", float64(len(keysPacked)))

	logger.Debug(ctx, fmt.Sprintf("Select packed tuple: '% X'", w))

	connection, err := octopus.Box(ctx, 0, activerecord.ReplicaOrMasterInstanceType, "arcfg", nil)
	if err != nil {
		metricErrCnt.Inc(ctx, "select_preparebox", 1)
		logger.Error(ctx, fmt.Sprintf("Error get box '%s'", err))

		return nil, err
	}

	respBytes, errCall := connection.Call(ctx, octopus.RequestTypeSelect, w)
	if errCall != nil {
		metricErrCnt.Inc(ctx, "select_box", 1)
		logger.Error(ctx, "Error select from box", errCall, connection.Info())

		return nil, errCall
	}

	metricTimer.Timing(ctx, "select_box")

	logger.Debug(ctx, fmt.Sprintf("Response from box '%X'", respBytes))

	tuplesData, err := octopus.ProcessResp(respBytes, 0)
	if err != nil {
		metricErrCnt.Inc(ctx, "select_resp", 1)
		logger.Error(ctx, "Error parse response: ", err)

		return nil, err
	}

	metricTimer.Timing(ctx, "select_process")
	metricStatCnt.Inc(ctx, "select_tuples_res", float64(len(tuplesData)))

	nps, err := NewFromBox(ctx, tuplesData)
	if err != nil {
		metricErrCnt.Inc(ctx, "select_preparebox", 1)
		logger.Error(ctx, "Error in response: ", err)

		return nil, err
	}

	metricTimer.Timing(ctx, "select_newobj")

	if limiter.FullfillWarn() && len(nps) == int(limiter.Limit()) {
		logger.Warn(ctx, "Select limit reached. Result may less than db records.")
	}

	mode, ok := connection.InstanceMode().(activerecord.ServerModeType)
	if !ok || mode == activerecord.ModeReplica {
		if !ok {
			logger.Error(ctx, "Invalid server mode type: %T", connection.InstanceMode())
		}

		for npNum := range nps {
			nps[npNum].IsReplica = true
			nps[npNum].Readonly = true
		}
	}

	logger.Debug(ctx, "Success select")

	metricTimer.Finish(ctx, "select")

	return nps, nil
}

// indexes

func (obj *Promoperiods) Primary() string {

	return obj.GetID()
}

func SelectByPrimary(ctx context.Context, pk string) (*Promoperiods, error) {
	return SelectByID(ctx, pk)
}

func PackKeyIndexID(ctx context.Context, keys []string) ([][][]byte, error) {
	keysPacked := [][][]byte{}

	for _, key := range keys {
		keysField := [][]byte{}
		keysField = append(keysField, octopus.PackString([]byte{}, key, iproto.ModeDefault))
		keysPacked = append(keysPacked, keysField)
	}

	return keysPacked, nil
}
func UnpackKeyIndexID(packedKeys [][][]byte) ([]string, error) {
	ret := []string{}

	for _, packedKey := range packedKeys {

		newIField, err := UnpackID(bytes.NewReader(packedKey[0]))
		if err != nil {
			return nil, fmt.Errorf("can't unpack index: %s", err)
		}

		ret = append(ret, newIField)
	}

	return ret, nil
}

/*
		keysPacked := [][][]byte{}

		for _, key := range keys {
			keysField := [][]byte{}
			keysField = append(keysField, octopus.PackString([]byte{}, key, iproto.ModeDefault))
			keysPacked = append(keysPacked, keysField)
		}

		return keysPacked, nil
	}
*/
func SelectByIDs(ctx context.Context, keys []string) ([]*Promoperiods, error) {
	ctx = activerecord.Logger().SetLoggerValueToContext(ctx, map[string]interface{}{"SelectByIDs": keys, "Repo": "Promoperiods"})

	keysPacked, err := PackKeyIndexID(ctx, keys)
	if err != nil {
		return nil, fmt.Errorf("can't pack index key: %s", err)
	}

	limiter := activerecord.EmptyLimiter()

	res, err := selectBox(ctx, 0, keysPacked, limiter)
	if err != nil {
		return res, err
	}

	activerecord.Logger().CollectQueries(ctx, SelectByIDMockerLogger(keys, PromoperiodsList(res)))

	return res, err
}

func SelectByID(ctx context.Context, key string) (*Promoperiods, error) {
	selected, err := SelectByIDs(ctx, []string{key})
	if err != nil {
		return nil, err
	}

	if len(selected) > 0 {
		if len(selected) > 1 {
			activerecord.Logger().Error(ctx, "Promoperiods", "More than one tuple for uniq key ID '%s': %d", key, len(selected))
		}

		return selected[0], nil
	}

	return nil, nil
}
func PackKeyIndexCode(ctx context.Context, keys []string) ([][][]byte, error) {
	keysPacked := [][][]byte{}

	for _, key := range keys {
		keysField := [][]byte{}
		keysField = append(keysField, octopus.PackString([]byte{}, key, iproto.ModeDefault))
		keysPacked = append(keysPacked, keysField)
	}

	return keysPacked, nil
}
func UnpackKeyIndexCode(packedKeys [][][]byte) ([]string, error) {
	ret := []string{}

	for _, packedKey := range packedKeys {

		newIField, err := UnpackCode(bytes.NewReader(packedKey[0]))
		if err != nil {
			return nil, fmt.Errorf("can't unpack index: %s", err)
		}

		ret = append(ret, newIField)
	}

	return ret, nil
}

/*
		keysPacked := [][][]byte{}

		for _, key := range keys {
			keysField := [][]byte{}
			keysField = append(keysField, octopus.PackString([]byte{}, key, iproto.ModeDefault))
			keysPacked = append(keysPacked, keysField)
		}

		return keysPacked, nil
	}
*/
func SelectByCodes(ctx context.Context, keys []string, limiter activerecord.SelectorLimiter) ([]*Promoperiods, error) {
	ctx = activerecord.Logger().SetLoggerValueToContext(ctx, map[string]interface{}{"SelectByCodes": keys, "Repo": "Promoperiods"})

	keysPacked, err := PackKeyIndexCode(ctx, keys)
	if err != nil {
		return nil, fmt.Errorf("can't pack index key: %s", err)
	}

	res, err := selectBox(ctx, 1, keysPacked, limiter)
	if err != nil {
		return res, err
	}

	activerecord.Logger().CollectQueries(ctx, SelectByCodeMockerLogger(keys, PromoperiodsList(res), limiter))

	return res, err
}

func SelectByCode(ctx context.Context, key string, limiter activerecord.SelectorLimiter) ([]*Promoperiods, error) {
	selected, err := SelectByCodes(ctx, []string{key}, limiter)
	if err != nil {
		return nil, err
	}

	return selected, nil
}
func PackKeyIndexEmail(ctx context.Context, keys []string) ([][][]byte, error) {
	keysPacked := [][][]byte{}

	for _, key := range keys {
		keysField := [][]byte{}
		keysField = append(keysField, octopus.PackString([]byte{}, key, iproto.ModeDefault))
		keysPacked = append(keysPacked, keysField)
	}

	return keysPacked, nil
}
func UnpackKeyIndexEmail(packedKeys [][][]byte) ([]string, error) {
	ret := []string{}

	for _, packedKey := range packedKeys {

		newIField, err := UnpackEmail(bytes.NewReader(packedKey[0]))
		if err != nil {
			return nil, fmt.Errorf("can't unpack index: %s", err)
		}

		ret = append(ret, newIField)
	}

	return ret, nil
}

/*
		keysPacked := [][][]byte{}

		for _, key := range keys {
			keysField := [][]byte{}
			keysField = append(keysField, octopus.PackString([]byte{}, key, iproto.ModeDefault))
			keysPacked = append(keysPacked, keysField)
		}

		return keysPacked, nil
	}
*/
func SelectByEmails(ctx context.Context, keys []string, limiter activerecord.SelectorLimiter) ([]*Promoperiods, error) {
	ctx = activerecord.Logger().SetLoggerValueToContext(ctx, map[string]interface{}{"SelectByEmails": keys, "Repo": "Promoperiods"})

	keysPacked, err := PackKeyIndexEmail(ctx, keys)
	if err != nil {
		return nil, fmt.Errorf("can't pack index key: %s", err)
	}

	res, err := selectBox(ctx, 2, keysPacked, limiter)
	if err != nil {
		return res, err
	}

	activerecord.Logger().CollectQueries(ctx, SelectByEmailMockerLogger(keys, PromoperiodsList(res), limiter))

	return res, err
}

func SelectByEmail(ctx context.Context, key string, limiter activerecord.SelectorLimiter) ([]*Promoperiods, error) {
	selected, err := SelectByEmails(ctx, []string{key}, limiter)
	if err != nil {
		return nil, err
	}

	return selected, nil
}

type PlanTypePriceIndexType struct {
	PlanType string

	Price float64
}

func PackKeyIndexPlanTypePrice(ctx context.Context, keys []PlanTypePriceIndexType) ([][][]byte, error) {
	keysPacked := [][][]byte{}

	for _, key := range keys {
		keysField := [][]byte{}

		keysField = append(keysField, octopus.PackString([]byte{}, key.PlanType, iproto.ModeDefault))

		skey, err := serializerJSON.PrintfMarshal("%.2f", key.Price)
		if err != nil {
			return nil, err
		}

		keysField = append(keysField, octopus.PackString([]byte{}, skey, iproto.ModeDefault))
		keysPacked = append(keysPacked, keysField)
	}

	return keysPacked, nil
}
func UnpackKeyIndexPlanTypePrice(packedKeys [][][]byte) ([]PlanTypePriceIndexType, error) {
	ret := []PlanTypePriceIndexType{}

	for _, packedKey := range packedKeys {

		newIField := PlanTypePriceIndexType{}

		var err error
		newIField.PlanType, err = UnpackPlanType(bytes.NewReader(packedKey[0]))
		if err != nil {
			return nil, fmt.Errorf("can't unpack index: %s", err)
		}

		newIField.Price, err = UnpackPrice(bytes.NewReader(packedKey[1]))
		if err != nil {
			return nil, fmt.Errorf("can't unpack index: %s", err)
		}

		ret = append(ret, newIField)
	}

	return ret, nil
}

/*
		keysPacked := [][][]byte{}

		for _, key := range keys {
			keysField := [][]byte{}



			keysField = append(keysField, octopus.PackString([]byte{}, key.PlanType, iproto.ModeDefault))


						skey, err := serializerJSON.PrintfMarshal("%.2f", key.Price)
						if err != nil {
							return nil, err
						}



			keysField = append(keysField, octopus.PackString([]byte{}, skey, iproto.ModeDefault))
				keysPacked = append(keysPacked, keysField)
		}

		return keysPacked, nil
	}
*/
func SelectByPlanTypePrices(ctx context.Context, keys []PlanTypePriceIndexType) ([]*Promoperiods, error) {
	ctx = activerecord.Logger().SetLoggerValueToContext(ctx, map[string]interface{}{"SelectByPlanTypePrices": keys, "Repo": "Promoperiods"})

	keysPacked, err := PackKeyIndexPlanTypePrice(ctx, keys)
	if err != nil {
		return nil, fmt.Errorf("can't pack index key: %s", err)
	}

	limiter := activerecord.EmptyLimiter()

	res, err := selectBox(ctx, 3, keysPacked, limiter)
	if err != nil {
		return res, err
	}

	activerecord.Logger().CollectQueries(ctx, SelectByPlanTypePriceMockerLogger(keys, PromoperiodsList(res)))

	return res, err
}

func SelectByPlanTypePrice(ctx context.Context, key PlanTypePriceIndexType) (*Promoperiods, error) {
	selected, err := SelectByPlanTypePrices(ctx, []PlanTypePriceIndexType{key})
	if err != nil {
		return nil, err
	}

	if len(selected) > 0 {
		if len(selected) > 1 {
			activerecord.Logger().Error(ctx, "Promoperiods", "More than one tuple for uniq key ID '%s': %d", key, len(selected))
		}

		return selected[0], nil
	}

	return nil, nil
}

type EmailCodeIndexType struct {
	Email string

	Code string
}

func PackKeyIndexEmailCode(ctx context.Context, keys []EmailCodeIndexType) ([][][]byte, error) {
	keysPacked := [][][]byte{}

	for _, key := range keys {
		keysField := [][]byte{}

		keysField = append(keysField, octopus.PackString([]byte{}, key.Email, iproto.ModeDefault))

		keysField = append(keysField, octopus.PackString([]byte{}, key.Code, iproto.ModeDefault))
		keysPacked = append(keysPacked, keysField)
	}

	return keysPacked, nil
}
func UnpackKeyIndexEmailCode(packedKeys [][][]byte) ([]EmailCodeIndexType, error) {
	ret := []EmailCodeIndexType{}

	for _, packedKey := range packedKeys {

		newIField := EmailCodeIndexType{}

		var err error
		newIField.Email, err = UnpackEmail(bytes.NewReader(packedKey[0]))
		if err != nil {
			return nil, fmt.Errorf("can't unpack index: %s", err)
		}

		newIField.Code, err = UnpackCode(bytes.NewReader(packedKey[1]))
		if err != nil {
			return nil, fmt.Errorf("can't unpack index: %s", err)
		}

		ret = append(ret, newIField)
	}

	return ret, nil
}

/*
		keysPacked := [][][]byte{}

		for _, key := range keys {
			keysField := [][]byte{}



			keysField = append(keysField, octopus.PackString([]byte{}, key.Email, iproto.ModeDefault))



			keysField = append(keysField, octopus.PackString([]byte{}, key.Code, iproto.ModeDefault))
				keysPacked = append(keysPacked, keysField)
		}

		return keysPacked, nil
	}
*/
func SelectByEmailCodes(ctx context.Context, keys []EmailCodeIndexType) ([]*Promoperiods, error) {
	ctx = activerecord.Logger().SetLoggerValueToContext(ctx, map[string]interface{}{"SelectByEmailCodes": keys, "Repo": "Promoperiods"})

	keysPacked, err := PackKeyIndexEmailCode(ctx, keys)
	if err != nil {
		return nil, fmt.Errorf("can't pack index key: %s", err)
	}

	limiter := activerecord.EmptyLimiter()

	res, err := selectBox(ctx, 4, keysPacked, limiter)
	if err != nil {
		return res, err
	}

	activerecord.Logger().CollectQueries(ctx, SelectByEmailCodeMockerLogger(keys, PromoperiodsList(res)))

	return res, err
}

func SelectByEmailCode(ctx context.Context, key EmailCodeIndexType) (*Promoperiods, error) {
	selected, err := SelectByEmailCodes(ctx, []EmailCodeIndexType{key})
	if err != nil {
		return nil, err
	}

	if len(selected) > 0 {
		if len(selected) > 1 {
			activerecord.Logger().Error(ctx, "Promoperiods", "More than one tuple for uniq key ID '%s': %d", key, len(selected))
		}

		return selected[0], nil
	}

	return nil, nil
}

type EmailActionIndexType struct {
	Email string

	Action string
}

func PackKeyIndexEmailAction(ctx context.Context, keys []EmailActionIndexType) ([][][]byte, error) {
	keysPacked := [][][]byte{}

	for _, key := range keys {
		keysField := [][]byte{}

		keysField = append(keysField, octopus.PackString([]byte{}, key.Email, iproto.ModeDefault))

		keysField = append(keysField, octopus.PackString([]byte{}, key.Action, iproto.ModeDefault))
		keysPacked = append(keysPacked, keysField)
	}

	return keysPacked, nil
}
func UnpackKeyIndexEmailAction(packedKeys [][][]byte) ([]EmailActionIndexType, error) {
	ret := []EmailActionIndexType{}

	for _, packedKey := range packedKeys {

		newIField := EmailActionIndexType{}

		var err error
		newIField.Email, err = UnpackEmail(bytes.NewReader(packedKey[0]))
		if err != nil {
			return nil, fmt.Errorf("can't unpack index: %s", err)
		}

		newIField.Action, err = UnpackAction(bytes.NewReader(packedKey[1]))
		if err != nil {
			return nil, fmt.Errorf("can't unpack index: %s", err)
		}

		ret = append(ret, newIField)
	}

	return ret, nil
}

/*
		keysPacked := [][][]byte{}

		for _, key := range keys {
			keysField := [][]byte{}



			keysField = append(keysField, octopus.PackString([]byte{}, key.Email, iproto.ModeDefault))



			keysField = append(keysField, octopus.PackString([]byte{}, key.Action, iproto.ModeDefault))
				keysPacked = append(keysPacked, keysField)
		}

		return keysPacked, nil
	}
*/
func SelectByEmailActions(ctx context.Context, keys []EmailActionIndexType) ([]*Promoperiods, error) {
	ctx = activerecord.Logger().SetLoggerValueToContext(ctx, map[string]interface{}{"SelectByEmailActions": keys, "Repo": "Promoperiods"})

	keysPacked, err := PackKeyIndexEmailAction(ctx, keys)
	if err != nil {
		return nil, fmt.Errorf("can't pack index key: %s", err)
	}

	limiter := activerecord.EmptyLimiter()

	res, err := selectBox(ctx, 5, keysPacked, limiter)
	if err != nil {
		return res, err
	}

	activerecord.Logger().CollectQueries(ctx, SelectByEmailActionMockerLogger(keys, PromoperiodsList(res)))

	return res, err
}

func SelectByEmailAction(ctx context.Context, key EmailActionIndexType) (*Promoperiods, error) {
	selected, err := SelectByEmailActions(ctx, []EmailActionIndexType{key})
	if err != nil {
		return nil, err
	}

	if len(selected) > 0 {
		if len(selected) > 1 {
			activerecord.Logger().Error(ctx, "Promoperiods", "More than one tuple for uniq key ID '%s': %d", key, len(selected))
		}

		return selected[0], nil
	}

	return nil, nil
}
func PackKeyIndexEmailPart(ctx context.Context, keys []string) ([][][]byte, error) {
	keysPacked := [][][]byte{}

	for _, key := range keys {
		keysField := [][]byte{}
		keysField = append(keysField, octopus.PackString([]byte{}, key, iproto.ModeDefault))
		keysPacked = append(keysPacked, keysField)
	}

	return keysPacked, nil
}
func UnpackKeyIndexEmailPart(packedKeys [][][]byte) ([]string, error) {
	ret := []string{}

	for _, packedKey := range packedKeys {

		newIField, err := UnpackEmail(bytes.NewReader(packedKey[0]))
		if err != nil {
			return nil, fmt.Errorf("can't unpack index: %s", err)
		}

		ret = append(ret, newIField)
	}

	return ret, nil
}

/*
		keysPacked := [][][]byte{}

		for _, key := range keys {
			keysField := [][]byte{}
			keysField = append(keysField, octopus.PackString([]byte{}, key, iproto.ModeDefault))
			keysPacked = append(keysPacked, keysField)
		}

		return keysPacked, nil
	}
*/
func SelectByEmailParts(ctx context.Context, keys []string, limiter activerecord.SelectorLimiter) ([]*Promoperiods, error) {
	ctx = activerecord.Logger().SetLoggerValueToContext(ctx, map[string]interface{}{"SelectByEmailParts": keys, "Repo": "Promoperiods"})

	keysPacked, err := PackKeyIndexEmailPart(ctx, keys)
	if err != nil {
		return nil, fmt.Errorf("can't pack index key: %s", err)
	}

	res, err := selectBox(ctx, 4, keysPacked, limiter)
	if err != nil {
		return res, err
	}

	activerecord.Logger().CollectQueries(ctx, SelectByEmailPartMockerLogger(keys, PromoperiodsList(res), limiter))

	return res, err
}

func SelectByEmailPart(ctx context.Context, key string, limiter activerecord.SelectorLimiter) ([]*Promoperiods, error) {
	selected, err := SelectByEmailParts(ctx, []string{key}, limiter)
	if err != nil {
		return nil, err
	}

	return selected, nil
}

// end indexes

func (obj *Promoperiods) GetPlan(ctx context.Context) (*arobj.ArObj, error) {
	if ret, ok := obj.BaseField.Objects["Plan"]; ok && len(ret) == 1 {
		return ret[0].(*arobj.ArObj), nil
	}

	ret, err := arobj.SelectByID(ctx, obj.GetPlanID())
	if err != nil {
		return nil, err
	}

	obj.BaseField.Objects["Plan"] = []octopus.ModelStruct{ret}

	return ret, nil
}

func (obj *Promoperiods) GetPlans(ctx context.Context) ([]*arobj.ArObj, error) {

	var ret []*arobj.ArObj

	if retI, ok := obj.BaseField.Objects["Plans"]; ok && len(retI) > 0 {
		for _, ri := range retI {
			ret = append(ret, ri.(*arobj.ArObj))
		}

		return ret, nil
	}

	ret, err := arobj.SelectByType(ctx, obj.GetPlanType(), activerecord.NewLimiter(100)) //ToDo default limit for multi object
	if err != nil {
		return nil, err
	}

	if len(ret) == 100 {
		activerecord.Logger().Warn(ctx, "limit for multiple linked object riched 'arobj.ArObj' 'Promoperiods'")
	}

	for _, r := range ret {
		obj.BaseField.Objects["Plans"] = append(obj.BaseField.Objects["Plans"], r)
	}

	return ret, nil
}

func (obj *Promoperiods) Equal(anotherObjI any) bool {
	anotherObj, ok := anotherObjI.(*Promoperiods)
	if !ok {
		return false
	}

	var dataObj []byte
	var dataAnotherObj []byte
	var err error
	dataObj, err = packID([]byte{}, obj.GetID())
	if err != nil {
		return false
	}

	dataAnotherObj, err = packID([]byte{}, anotherObj.GetID())
	if err != nil {
		return false
	}

	if string(dataObj) != string(dataAnotherObj) {
		return false
	}

	dataObj, err = packCode([]byte{}, obj.GetCode())
	if err != nil {
		return false
	}

	dataAnotherObj, err = packCode([]byte{}, anotherObj.GetCode())
	if err != nil {
		return false
	}

	if string(dataObj) != string(dataAnotherObj) {
		return false
	}

	dataObj, err = packEmail([]byte{}, obj.GetEmail())
	if err != nil {
		return false
	}

	dataAnotherObj, err = packEmail([]byte{}, anotherObj.GetEmail())
	if err != nil {
		return false
	}

	if string(dataObj) != string(dataAnotherObj) {
		return false
	}

	dataObj, err = packStart([]byte{}, obj.GetStart())
	if err != nil {
		return false
	}

	dataAnotherObj, err = packStart([]byte{}, anotherObj.GetStart())
	if err != nil {
		return false
	}

	if string(dataObj) != string(dataAnotherObj) {
		return false
	}

	dataObj, err = packFinish([]byte{}, obj.GetFinish())
	if err != nil {
		return false
	}

	dataAnotherObj, err = packFinish([]byte{}, anotherObj.GetFinish())
	if err != nil {
		return false
	}

	if string(dataObj) != string(dataAnotherObj) {
		return false
	}

	dataObj, err = packAction([]byte{}, obj.GetAction())
	if err != nil {
		return false
	}

	dataAnotherObj, err = packAction([]byte{}, anotherObj.GetAction())
	if err != nil {
		return false
	}

	if string(dataObj) != string(dataAnotherObj) {
		return false
	}

	dataObj, err = packPlatform([]byte{}, obj.GetPlatform())
	if err != nil {
		return false
	}

	dataAnotherObj, err = packPlatform([]byte{}, anotherObj.GetPlatform())
	if err != nil {
		return false
	}

	if string(dataObj) != string(dataAnotherObj) {
		return false
	}

	dataObj, err = packPromobunch([]byte{}, obj.GetPromobunch())
	if err != nil {
		return false
	}

	dataAnotherObj, err = packPromobunch([]byte{}, anotherObj.GetPromobunch())
	if err != nil {
		return false
	}

	if string(dataObj) != string(dataAnotherObj) {
		return false
	}

	dataObj, err = packPlatforms([]byte{}, obj.GetPlatforms())
	if err != nil {
		return false
	}

	dataAnotherObj, err = packPlatforms([]byte{}, anotherObj.GetPlatforms())
	if err != nil {
		return false
	}

	if string(dataObj) != string(dataAnotherObj) {
		return false
	}

	dataObj, err = packPlanID([]byte{}, obj.GetPlanID())
	if err != nil {
		return false
	}

	dataAnotherObj, err = packPlanID([]byte{}, anotherObj.GetPlanID())
	if err != nil {
		return false
	}

	if string(dataObj) != string(dataAnotherObj) {
		return false
	}

	dataObj, err = packPlanType([]byte{}, obj.GetPlanType())
	if err != nil {
		return false
	}

	dataAnotherObj, err = packPlanType([]byte{}, anotherObj.GetPlanType())
	if err != nil {
		return false
	}

	if string(dataObj) != string(dataAnotherObj) {
		return false
	}

	dataObj, err = packPrice([]byte{}, obj.GetPrice())
	if err != nil {
		return false
	}

	dataAnotherObj, err = packPrice([]byte{}, anotherObj.GetPrice())
	if err != nil {
		return false
	}

	if string(dataObj) != string(dataAnotherObj) {
		return false
	}

	return true
}

func (obj *Promoperiods) PrimaryString() string {
	ret := []string{
		obj.GetID(),
	}

	return strings.Join(ret, ", ")
}

func (obj *Promoperiods) packPk() ([][]byte, error) {
	packedPk := [][]byte{}

	var (
		data []byte
		err  error
	)

	data, err = packID([]byte{}, obj.GetID())
	if err != nil {
		return [][]byte{}, err
	}

	packedPk = append(packedPk, data)

	return packedPk, nil
}

func (obj *Promoperiods) Delete(ctx context.Context) error {
	logger := activerecord.Logger()
	metricTimer := activerecord.Metric().Timer("octopus", "Promoperiods")
	metricStatCnt := activerecord.Metric().StatCount("octopus", "Promoperiods")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "Promoperiods")

	metricStatCnt.Inc(ctx, "delete_request", 1)

	if !obj.BaseField.Exists {
		return fmt.Errorf("can't delete not exists object")
	}

	pk, err := obj.packPk()
	if err != nil {
		metricErrCnt.Inc(ctx, "delete_pack", 1)
		return fmt.Errorf("error delete: %w", err)
	}

	w := octopus.PackDelete(namespace, pk)
	log.Printf("Delete packed tuple: '%X'\n", w)

	connection, err := octopus.Box(ctx, 0, activerecord.MasterInstanceType, "arcfg", nil)
	if err != nil {
		metricErrCnt.Inc(ctx, "delete_preparebox", 1)
		logger.Error(ctx, "Promoperiods", obj.PrimaryString(), fmt.Sprintf("Error get box '%s'", err))

		return err
	}

	respBytes, errCall := connection.Call(ctx, octopus.RequestTypeDelete, w)
	if errCall != nil {
		metricErrCnt.Inc(ctx, "delete_box", 1)
		logger.Error(ctx, "Promoperiods", obj.PrimaryString(), "Error delete from box", errCall, connection.Info())

		return errCall
	}

	metricTimer.Timing(ctx, "delete_box")

	logger.Debug(ctx, "Promoperiods", obj.PrimaryString(), fmt.Sprintf("Response from box '% X'", respBytes))

	_, err = octopus.ProcessResp(respBytes, octopus.NeedRespFlag|octopus.UniqRespFlag)
	if err != nil {
		metricErrCnt.Inc(ctx, "delete_resp", 1)
		logger.Error(ctx, "Promoperiods", obj.PrimaryString(), "Error parse response: ", err)

		return err
	}

	metricStatCnt.Inc(ctx, "delete_success", 1)

	obj.BaseField.Exists = false
	obj.BaseField.UpdateOps = []octopus.Ops{}

	logger.Debug(ctx, "Promoperiods", obj.PrimaryString(), "Success delete")

	metricTimer.Finish(ctx, "delete")

	return nil
}

func (obj *Promoperiods) Update(ctx context.Context) error {
	logger := activerecord.Logger()
	metricTimer := activerecord.Metric().Timer("octopus", "Promoperiods")
	metricStatCnt := activerecord.Metric().StatCount("octopus", "Promoperiods")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "Promoperiods")

	metricStatCnt.Inc(ctx, "update_request", 1)

	if !obj.BaseField.Exists {
		metricErrCnt.Inc(ctx, "update_notexists", 1)
		return fmt.Errorf("can't update not exists object")
	}

	if obj.BaseField.Repaired {
		metricStatCnt.Inc(ctx, "update_repaired", 1)
		logger.Debug(ctx, "", obj.PrimaryString(), "Flag 'Repaired' is true! Insert instead Update")

		return obj.Replace(ctx)
	}

	connection, err := octopus.Box(ctx, 0, activerecord.MasterInstanceType, "arcfg", nil)
	if err != nil {
		metricErrCnt.Inc(ctx, "update_preparebox", 1)
		logger.Error(ctx, "Promoperiods", obj.PrimaryString(), fmt.Sprintf("Error get box '%s'", err))
		return err
	}

	if len(obj.BaseField.UpdateOps) == 0 {
		metricStatCnt.Inc(ctx, "update_empty", 1)
		logger.Debug(ctx, "", obj.PrimaryString(), "Empty update")

		return nil
	}

	pk, err := obj.packPk()
	if err != nil {
		metricErrCnt.Inc(ctx, "update_packpk", 1)
		return fmt.Errorf("error update: %w", err)
	}

	w := octopus.PackUpdate(namespace, pk, obj.BaseField.UpdateOps)

	log.Printf("Update packed tuple: '%X'\n", w)

	respBytes, errCall := connection.Call(ctx, octopus.RequestTypeUpdate, w)
	if errCall != nil {
		metricErrCnt.Inc(ctx, "update_box", 1)
		logger.Error(ctx, "Promoperiods", obj.PrimaryString(), "Error update ia a box", errCall, connection.Info())
		return errCall
	}

	metricTimer.Timing(ctx, "update_box")

	logger.Debug(ctx, "Promoperiods", obj.PrimaryString(), fmt.Sprintf("Response from box '%X'", respBytes))

	_, err = octopus.ProcessResp(respBytes, octopus.NeedRespFlag|octopus.UniqRespFlag)
	if err != nil {
		metricErrCnt.Inc(ctx, "update_resp", 1)
		logger.Error(ctx, "Promoperiods", obj.PrimaryString(), "Error parse response: ", err)
		return err
	}

	obj.BaseField.UpdateOps = []octopus.Ops{}

	logger.Debug(ctx, "Promoperiods", obj.PrimaryString(), "Success update")

	metricStatCnt.Inc(ctx, "update_success", 1)
	metricTimer.Finish(ctx, "update")

	return nil
}

func (obj *Promoperiods) Insert(ctx context.Context) error {
	metricStatCnt := activerecord.Metric().StatCount("octopus", "Promoperiods")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "Promoperiods")

	metricStatCnt.Inc(ctx, "insert_request", 1)

	if obj.BaseField.Exists {
		metricErrCnt.Inc(ctx, "insert_exists", 1)
		return fmt.Errorf("can't insert already exists object")
	}

	err := obj.insertReplace(ctx, octopus.InsertModeInsert)

	if err == nil {
		metricStatCnt.Inc(ctx, "insert_success", 1)
	}

	return err
}

func (obj *Promoperiods) Replace(ctx context.Context) error {
	metricStatCnt := activerecord.Metric().StatCount("octopus", "Promoperiods")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "Promoperiods")

	metricStatCnt.Inc(ctx, "replace_request", 1)

	if !obj.BaseField.Exists {
		metricErrCnt.Inc(ctx, "replace_notexists", 1)
		return fmt.Errorf("can't replace not exists object")
	}

	err := obj.insertReplace(ctx, octopus.InsertModeReplace)

	if err == nil {
		metricStatCnt.Inc(ctx, "replace_success", 1)
	}

	return err
}

func (obj *Promoperiods) InsertOrReplace(ctx context.Context) error {
	metricStatCnt := activerecord.Metric().StatCount("octopus", "Promoperiods")

	metricStatCnt.Inc(ctx, "insertorreplace_request", 1)

	err := obj.insertReplace(ctx, octopus.InsertModeInserOrReplace)

	if err == nil {
		metricStatCnt.Inc(ctx, "insertorreplace_success", 1)
	}

	return err
}

func (obj *Promoperiods) insertReplace(ctx context.Context, insertMode octopus.InsertMode) error {
	var (
		err   error
		tuple [][]byte
		data  []byte
	)

	metricTimer := activerecord.Metric().Timer("octopus", "Promoperiods")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "Promoperiods")

	data, err = packID([]byte{}, obj.GetID())
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_packfield", 1)
		return err
	}

	tuple = append(tuple, data)

	data, err = packCode([]byte{}, obj.GetCode())
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_packfield", 1)
		return err
	}

	tuple = append(tuple, data)

	data, err = packEmail([]byte{}, obj.GetEmail())
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_packfield", 1)
		return err
	}

	tuple = append(tuple, data)

	data, err = packStart([]byte{}, obj.GetStart())
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_packfield", 1)
		return err
	}

	tuple = append(tuple, data)

	data, err = packFinish([]byte{}, obj.GetFinish())
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_packfield", 1)
		return err
	}

	tuple = append(tuple, data)

	data, err = packAction([]byte{}, obj.GetAction())
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_packfield", 1)
		return err
	}

	tuple = append(tuple, data)

	data, err = packPlatform([]byte{}, obj.GetPlatform())
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_packfield", 1)
		return err
	}

	tuple = append(tuple, data)

	data, err = packPromobunch([]byte{}, obj.GetPromobunch())
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_packfield", 1)
		return err
	}

	tuple = append(tuple, data)

	data, err = packPlatforms([]byte{}, obj.GetPlatforms())
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_packfield", 1)
		return err
	}

	tuple = append(tuple, data)

	data, err = packPlanID([]byte{}, obj.GetPlanID())
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_packfield", 1)
		return err
	}

	tuple = append(tuple, data)

	data, err = packPlanType([]byte{}, obj.GetPlanType())
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_packfield", 1)
		return err
	}

	tuple = append(tuple, data)

	data, err = packPrice([]byte{}, obj.GetPrice())
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_packfield", 1)
		return err
	}

	tuple = append(tuple, data)

	metricTimer.Timing(ctx, "insertreplace_packtuple")

	if len(obj.BaseField.ExtraFields) > 0 {
		tuple = append(tuple, obj.BaseField.ExtraFields...)
	}

	w := octopus.PackInsertReplace(namespace, insertMode, tuple)
	logger := activerecord.Logger()

	metricTimer.Timing(ctx, "insertreplace_pack")
	logger.Trace(ctx, "Promoperiods", obj.PrimaryString(), fmt.Sprintf("Insert packed tuple: '%X'", w))

	connection, err := octopus.Box(ctx, 0, activerecord.MasterInstanceType, "arcfg", nil)
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_preparebox", 1)
		logger.Error(ctx, "Promoperiods", obj.PrimaryString(), fmt.Sprintf("Error get box '%s'", err))

		return err
	}

	respBytes, errCall := connection.Call(ctx, octopus.RequestTypeInsert, w)
	if errCall != nil {
		metricErrCnt.Inc(ctx, "insertreplace_box", 1)
		logger.Error(ctx, "Promoperiods", obj.PrimaryString(), "Error insert into box", errCall, connection.Info())

		return errCall
	}

	metricTimer.Timing(ctx, "insertreplace_box")

	logger.Trace(ctx, "Promoperiods", obj.PrimaryString(), fmt.Sprintf("Response from box '%X'", respBytes))

	tuplesData, err := octopus.ProcessResp(respBytes, octopus.NeedRespFlag|octopus.UniqRespFlag)
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_prespreparebox", 1)
		logger.Error(ctx, "Promoperiods", obj.PrimaryString(), "Error parse response: ", err)

		return err
	}

	_, err = NewFromBox(ctx, tuplesData)
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_obj", 1)
		logger.Error(ctx, "Promoperiods", obj.PrimaryString(), "Error in response: ", err)

		return err
	}

	obj.BaseField.Exists = true
	obj.BaseField.UpdateOps = []octopus.Ops{}
	obj.BaseField.Repaired = false

	logger.Debug(ctx, "Promoperiods", obj.PrimaryString(), "Success insert")

	metricTimer.Finish(ctx, "insertreplace")

	return nil
}
