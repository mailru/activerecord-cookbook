// Code generated by argen. DO NOT EDIT.
// This code was generated from a template.
//
// Manual changes to this file may cause unexpected behavior in your application.
// Manual changes to this file will be overwritten if the code is regenerated.
//
// Generate info: argen@v1.5.3-1-g5a0f936 (Commit: 5a0f936d)
package foo

import (
	"context"
	"fmt"
	"time"

	"github.com/mailru/activerecord/pkg/activerecord"
	"github.com/mailru/activerecord/pkg/octopus"
)

// proc struct
type Foo struct {
	fieldTraceID string

	fieldStatus string

	fieldJsonRawData string
}

const (
	procName string = "bar.foo"
)

func (obj *Foo) GetTraceID() string {
	return obj.fieldTraceID
}

func (obj *Foo) GetStatus() string {
	return obj.fieldStatus
}

func (obj *Foo) GetJsonRawData() string {
	return obj.fieldJsonRawData
}

type FooParams struct {
	SearchQuery string

	TraceID string
}

func Call(ctx context.Context, params FooParams) (*Foo, error) {
	c, _ := box(ctx, 0, activerecord.ReplicaInstanceType)

	td, err := octopus.CallLua(ctx, c, procName)
	if err != nil {
		return nil, fmt.Errorf("call lua procedure %s: %w", procName, err)
	}

	_ = td

	return nil, nil
}

// end proc struct

var boxOption, _ = octopus.NewOptions(
	"box1:",
	octopus.ModeMaster,
	octopus.WithTimeout(time.Millisecond*0, time.Millisecond*0),
)

var clusterInfo = activerecord.NewClusterInfo(
	activerecord.WithShard([]activerecord.OptionInterface{boxOption}, []activerecord.OptionInterface{}),
)

// box - возвращает коннектор для БД
// TODO
// - унести в пакет pkg/octopus тут общий код нет смысла его нагенеривать
// - сделать статистику по используемым инстансам
// - прикрутить локальный пингер и исключать недоступные инстансы
func box(ctx context.Context, shard int, instType activerecord.ShardInstanceType) (*octopus.Connection, error) {

	var configBox activerecord.ShardInstance

	switch instType {
	case activerecord.ReplicaInstanceType:
		if len(clusterInfo[shard].Replicas) == 0 {
			return nil, fmt.Errorf("replicas not set")
		}

		configBox = clusterInfo[shard].NextReplica()
	case activerecord.ReplicaOrMasterInstanceType:
		if len(clusterInfo[shard].Replicas) != 0 {
			configBox = clusterInfo[shard].NextReplica()
			break
		}

		fallthrough
	case activerecord.MasterInstanceType:
		configBox = clusterInfo[shard].NextMaster()
	}

	conn, err := activerecord.ConnectionCacher().GetOrAdd(configBox, func(options interface{}) (activerecord.ConnectionInterface, error) {
		octopusOpt, ok := options.(*octopus.ConnectionOptions)
		if !ok {
			return nil, fmt.Errorf("invalit type of options %T, want Options", options)
		}

		return octopus.GetConnection(ctx, octopusOpt)
	})
	if err != nil {
		return nil, fmt.Errorf("error from connectionCacher: %w", err)
	}

	box, ok := conn.(*octopus.Connection)
	if !ok {
		return nil, fmt.Errorf("invalid connection type %T, want *octopus.Connection", conn)
	}

	return box, nil
}
