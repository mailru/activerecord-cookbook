// Code generated by argen. DO NOT EDIT.
// This code was generated from a template.
//
// Manual changes to this file may cause unexpected behavior in your application.
// Manual changes to this file will be overwritten if the code is regenerated.
//
// Generate info: argen@v1.5.3-3-g773f54b (Commit: 773f54bd)
package boolindexed

import (
	"bytes"
	"context"
	"fmt"
	"log"

	"strings"

	"github.com/mailru/activerecord/pkg/activerecord"
	"github.com/mailru/activerecord/pkg/iproto/iproto"
	"github.com/mailru/activerecord/pkg/octopus"
)

type Boolindexed struct {
	octopus.BaseField
	fieldCode      string
	fieldInvisible bool
}

type BoolindexedList []*Boolindexed

const (
	namespace uint32 = 25
	cntFields uint32 = 2
)

// box - возвращает коннектор для БД
// TODO
// - унести в пакет pkg/octopus тут общий код нет смысла его нагенеривать
// - сделать статистику по используемым инстансам
// - прикрутить локальный пингер и исключать недоступные инстансы
func box(ctx context.Context, shard int, instType activerecord.ShardInstanceType) (*octopus.Connection, error) {
	configPath := "arcfg"

	clusterInfo, err := activerecord.ConfigCacher().Get(
		ctx,
		configPath,
		activerecord.MapGlobParam{
			Timeout:  octopus.DefaultConnectionTimeout,
			PoolSize: octopus.DefaultPoolSize,
		},
		func(sic activerecord.ShardInstanceConfig) (activerecord.OptionInterface, error) {
			return octopus.NewOptions(
				sic.Addr,
				octopus.ServerModeType(sic.Mode),
				octopus.WithTimeout(sic.Timeout, sic.Timeout),
				octopus.WithPoolSize(sic.PoolSize),
			)
		},
	)
	if err != nil {
		return nil, fmt.Errorf("can't get cluster %s info: %w", configPath, err)
	}

	if len(clusterInfo) < int(shard) {
		return nil, fmt.Errorf("invalid shard num %d, max = %d", shard, len(clusterInfo))
	}

	var configBox activerecord.ShardInstance

	switch instType {
	case activerecord.ReplicaInstanceType:
		if len(clusterInfo[shard].Replicas) == 0 {
			return nil, fmt.Errorf("replicas not set")
		}

		configBox = clusterInfo[shard].NextReplica()
	case activerecord.ReplicaOrMasterInstanceType:
		if len(clusterInfo[shard].Replicas) != 0 {
			configBox = clusterInfo[shard].NextReplica()
			break
		}

		fallthrough
	case activerecord.MasterInstanceType:
		configBox = clusterInfo[shard].NextMaster()
	}

	conn, err := activerecord.ConnectionCacher().GetOrAdd(configBox, func(options interface{}) (activerecord.ConnectionInterface, error) {
		octopusOpt, ok := options.(*octopus.ConnectionOptions)
		if !ok {
			return nil, fmt.Errorf("invalit type of options %T, want Options", options)
		}

		return octopus.GetConnection(ctx, octopusOpt)
	})
	if err != nil {
		return nil, fmt.Errorf("error from connectionCacher: %w", err)
	}

	box, ok := conn.(*octopus.Connection)
	if !ok {
		return nil, fmt.Errorf("invalid connection type %T, want *octopus.Connection", conn)
	}

	return box, nil
}

func New(ctx context.Context) *Boolindexed {
	newObj := Boolindexed{}
	newObj.BaseField.UpdateOps = []octopus.Ops{}
	newObj.BaseField.ExtraFields = [][]byte{}
	newObj.BaseField.Objects = map[string][]octopus.ModelStruct{}

	return &newObj
}

func TupleToStruct(ctx context.Context, tuple octopus.TupleData) (*Boolindexed, error) {
	np := New(ctx)

	valCode, err := UnpackCode(bytes.NewReader(tuple.Data[0]))
	if err != nil {
		return nil, err
	}

	np.SetCode(valCode)
	valInvisible, err := UnpackInvisible(bytes.NewReader(tuple.Data[1]))
	if err != nil {
		return nil, err
	}

	np.SetInvisible(valInvisible)

	np.BaseField.Exists = true
	np.BaseField.UpdateOps = []octopus.Ops{}

	if tuple.Cnt > cntFields {
		logger := activerecord.Logger()

		logger.Warn(ctx, "Boolindexed", np.PrimaryString(), "Extra fields")

		np.BaseField.ExtraFields = tuple.Data[cntFields:]
	}

	return np, nil
}

func NewFromBox(ctx context.Context, tuples []octopus.TupleData) ([]*Boolindexed, error) {
	logger := activerecord.Logger()

	logger.Debug(ctx, "Boolindexed", fmt.Sprintf("Cnt tuples %d", len(tuples)))

	ret := make([]*Boolindexed, 0, len(tuples))

	for num, tuple := range tuples {
		var repaired bool

		if tuple.Cnt < cntFields {
			return nil, fmt.Errorf("not enought selected fields %d in response tuple: %d but expected %d fields", tuple.Cnt, num, cntFields)
		}

		np, err := TupleToStruct(ctx, tuple)
		if err != nil {
			logger.Error(ctx, "Boolindexed", fmt.Sprintf("error unpack tuple %s", err))
			return nil, err
		}

		np.BaseField.Repaired = repaired
		ret = append(ret, np)
	}

	return ret, nil
}
func packCode(w []byte, Code string) ([]byte, error) {
	pvar := Code

	return octopus.PackString(w, pvar, iproto.ModeDefault), nil
}

func UnpackCode(r *bytes.Reader) (ret string, errRet error) {
	var Code string

	err := octopus.UnpackString(r, &Code, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field Code in tuple: '%w'", err)
		return
	}

	bvar := Code

	svar := bvar

	return svar, nil
}

func (obj *Boolindexed) GetCode() string {
	return obj.fieldCode
}

func (obj *Boolindexed) SetCode(Code string) error {
	if obj.BaseField.Exists {
		return fmt.Errorf("can't modify field included in primary key")
	}

	data, err := packCode([]byte{}, Code)
	if err != nil {
		return err
	}

	logger := activerecord.Logger()

	logger.Warn(context.TODO(), "Boolindexed", obj.PrimaryString(), fmt.Sprintf("Size for field 'Code' not set. Cur field size: %d. Object: 'Boolindexed'", len(data)))

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 0, Op: octopus.OpSet, Value: data})
	obj.fieldCode = Code

	return nil
}

func packInvisible(w []byte, Invisible bool) ([]byte, error) {
	pvar := octopus.BoolToUint(Invisible)

	return iproto.PackUint8(w, pvar, iproto.ModeDefault), nil
}

func UnpackInvisible(r *bytes.Reader) (ret bool, errRet error) {
	var Invisible uint8

	err := iproto.UnpackUint8(r, &Invisible, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field Invisible in tuple: '%w'", err)
		return
	}

	bvar := octopus.UintToBool(Invisible)

	svar := bvar

	return svar, nil
}

func (obj *Boolindexed) GetInvisible() bool {
	return obj.fieldInvisible
}

func (obj *Boolindexed) SetInvisible(Invisible bool) error {
	data, err := packInvisible([]byte{}, Invisible)
	if err != nil {
		return err
	}

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: 1, Op: octopus.OpSet, Value: data})
	obj.fieldInvisible = Invisible

	return nil
}

func selectBox(ctx context.Context, indexnum uint32, keysPacked [][][]byte, limiter activerecord.SelectorLimiter) ([]*Boolindexed, error) {
	logger := activerecord.Logger()
	ctx = logger.SetLoggerValueToContext(ctx, activerecord.ValueLogPrefix{"limiter": limiter.String()})
	metricTimer := activerecord.Metric().Timer("octopus", "Boolindexed")
	metricStatCnt := activerecord.Metric().StatCount("octopus", "Boolindexed")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "Boolindexed")

	w := octopus.PackSelect(namespace, indexnum, limiter.Offset(), limiter.Limit(), keysPacked)

	metricTimer.Timing(ctx, "select_pack")
	metricStatCnt.Inc(ctx, "select_keys", float64(len(keysPacked)))

	logger.Debug(ctx, fmt.Sprintf("Select packed tuple: '% X'", w))

	connection, err := box(ctx, 0, activerecord.ReplicaOrMasterInstanceType)
	if err != nil {
		metricErrCnt.Inc(ctx, "select_preparebox", 1)
		logger.Error(ctx, fmt.Sprintf("Error get box '%s'", err))

		return nil, err
	}

	respBytes, errCall := connection.Call(ctx, octopus.RequestTypeSelect, w)
	if errCall != nil {
		metricErrCnt.Inc(ctx, "select_box", 1)
		logger.Error(ctx, "Error select from box", errCall, connection.Info())

		return nil, errCall
	}

	metricTimer.Timing(ctx, "select_box")

	logger.Debug(ctx, fmt.Sprintf("Response from box '%X'", respBytes))

	tuplesData, err := octopus.ProcessResp(respBytes, 0)
	if err != nil {
		metricErrCnt.Inc(ctx, "select_resp", 1)
		logger.Error(ctx, "Error parse response: ", err)

		return nil, err
	}

	metricTimer.Timing(ctx, "select_process")
	metricStatCnt.Inc(ctx, "select_tuples_res", float64(len(tuplesData)))

	nps, err := NewFromBox(ctx, tuplesData)
	if err != nil {
		metricErrCnt.Inc(ctx, "select_preparebox", 1)
		logger.Error(ctx, "Error in response: ", err)

		return nil, err
	}

	metricTimer.Timing(ctx, "select_newobj")

	if limiter.FullfillWarn() && len(nps) == int(limiter.Limit()) {
		logger.Warn(ctx, "Select limit reached. Result may less than db records.")
	}

	mode, ok := connection.InstanceMode().(octopus.ServerModeType)
	if !ok || activerecord.ServerModeType(mode) == activerecord.ModeReplica {
		if !ok {
			logger.Error(ctx, "Invalid server mode type: %T", connection.InstanceMode())
		}

		for npNum := range nps {
			nps[npNum].IsReplica = true
			nps[npNum].Readonly = true
		}
	}

	logger.Debug(ctx, "Success select")

	metricTimer.Finish(ctx, "select")

	return nps, nil
}

// indexes

func (obj *Boolindexed) Primary() string {

	return obj.GetCode()
}

func SelectByPrimary(ctx context.Context, pk string) (*Boolindexed, error) {
	return SelectByCode(ctx, pk)
}

func PackKeyIndexCode(ctx context.Context, keys []string) ([][][]byte, error) {
	keysPacked := [][][]byte{}

	for _, key := range keys {
		keysField := [][]byte{}
		keysField = append(keysField, octopus.PackString([]byte{}, key, iproto.ModeDefault))
		keysPacked = append(keysPacked, keysField)
	}

	return keysPacked, nil
}
func UnpackKeyIndexCode(packedKeys [][][]byte) ([]string, error) {
	ret := []string{}

	for _, packedKey := range packedKeys {

		newIField, err := UnpackCode(bytes.NewReader(packedKey[0]))
		if err != nil {
			return nil, fmt.Errorf("can't unpack index: %s", err)
		}

		ret = append(ret, newIField)
	}

	return ret, nil
}

/*
		keysPacked := [][][]byte{}

		for _, key := range keys {
			keysField := [][]byte{}
			keysField = append(keysField, octopus.PackString([]byte{}, key, iproto.ModeDefault))
			keysPacked = append(keysPacked, keysField)
		}

		return keysPacked, nil
	}
*/
func SelectByCodes(ctx context.Context, keys []string) ([]*Boolindexed, error) {
	ctx = activerecord.Logger().SetLoggerValueToContext(ctx, map[string]interface{}{"SelectByCodes": keys, "Repo": "Boolindexed"})

	keysPacked, err := PackKeyIndexCode(ctx, keys)
	if err != nil {
		return nil, fmt.Errorf("can't pack index key: %s", err)
	}

	limiter := activerecord.EmptyLimiter()

	res, err := selectBox(ctx, 0, keysPacked, limiter)
	if err != nil {
		return res, err
	}

	activerecord.Logger().CollectQueries(ctx, SelectByCodeMockerLogger(keys, BoolindexedList(res)))

	return res, err
}

func SelectByCode(ctx context.Context, key string) (*Boolindexed, error) {
	selected, err := SelectByCodes(ctx, []string{key})
	if err != nil {
		return nil, err
	}

	if len(selected) > 0 {
		if len(selected) > 1 {
			activerecord.Logger().Error(ctx, "Boolindexed", "More than one tuple for uniq key ID '%s': %d", key, len(selected))
		}

		return selected[0], nil
	}

	return nil, nil
}
func PackKeyIndexInvisible(ctx context.Context, keys []bool) ([][][]byte, error) {
	keysPacked := [][][]byte{}

	for _, key := range keys {
		keysField := [][]byte{}
		keysField = append(keysField, iproto.PackUint8([]byte{}, octopus.BoolToUint(key), iproto.ModeDefault))
		keysPacked = append(keysPacked, keysField)
	}

	return keysPacked, nil
}
func UnpackKeyIndexInvisible(packedKeys [][][]byte) ([]bool, error) {
	ret := []bool{}

	for _, packedKey := range packedKeys {

		newIField, err := UnpackInvisible(bytes.NewReader(packedKey[1]))
		if err != nil {
			return nil, fmt.Errorf("can't unpack index: %s", err)
		}

		ret = append(ret, newIField)
	}

	return ret, nil
}

/*
		keysPacked := [][][]byte{}

		for _, key := range keys {
			keysField := [][]byte{}
			keysField = append(keysField, iproto.PackUint8([]byte{}, octopus.BoolToUint(key), iproto.ModeDefault))
			keysPacked = append(keysPacked, keysField)
		}

		return keysPacked, nil
	}
*/
func SelectByInvisibles(ctx context.Context, keys []bool, limiter activerecord.SelectorLimiter) ([]*Boolindexed, error) {
	ctx = activerecord.Logger().SetLoggerValueToContext(ctx, map[string]interface{}{"SelectByInvisibles": keys, "Repo": "Boolindexed"})

	keysPacked, err := PackKeyIndexInvisible(ctx, keys)
	if err != nil {
		return nil, fmt.Errorf("can't pack index key: %s", err)
	}

	res, err := selectBox(ctx, 1, keysPacked, limiter)
	if err != nil {
		return res, err
	}

	activerecord.Logger().CollectQueries(ctx, SelectByInvisibleMockerLogger(keys, BoolindexedList(res), limiter))

	return res, err
}

func SelectByInvisible(ctx context.Context, key bool, limiter activerecord.SelectorLimiter) ([]*Boolindexed, error) {
	selected, err := SelectByInvisibles(ctx, []bool{key}, limiter)
	if err != nil {
		return nil, err
	}

	return selected, nil
}

// end indexes

func (obj *Boolindexed) Equal(anotherObjI any) bool {
	anotherObj, ok := anotherObjI.(*Boolindexed)
	if !ok {
		return false
	}

	var dataObj []byte
	var dataAnotherObj []byte
	var err error
	dataObj, err = packCode([]byte{}, obj.GetCode())
	if err != nil {
		return false
	}

	dataAnotherObj, err = packCode([]byte{}, anotherObj.GetCode())
	if err != nil {
		return false
	}

	if string(dataObj) != string(dataAnotherObj) {
		return false
	}

	dataObj, err = packInvisible([]byte{}, obj.GetInvisible())
	if err != nil {
		return false
	}

	dataAnotherObj, err = packInvisible([]byte{}, anotherObj.GetInvisible())
	if err != nil {
		return false
	}

	if string(dataObj) != string(dataAnotherObj) {
		return false
	}

	return true
}

func (obj *Boolindexed) PrimaryString() string {
	ret := []string{
		obj.GetCode(),
	}

	return strings.Join(ret, ", ")
}

func (obj *Boolindexed) packPk() ([][]byte, error) {
	packedPk := [][]byte{}

	var (
		data []byte
		err  error
	)

	data, err = packCode([]byte{}, obj.GetCode())
	if err != nil {
		return [][]byte{}, err
	}

	packedPk = append(packedPk, data)

	return packedPk, nil
}

func (obj *Boolindexed) Delete(ctx context.Context) error {
	logger := activerecord.Logger()
	metricTimer := activerecord.Metric().Timer("octopus", "Boolindexed")
	metricStatCnt := activerecord.Metric().StatCount("octopus", "Boolindexed")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "Boolindexed")

	metricStatCnt.Inc(ctx, "delete_request", 1)

	if !obj.BaseField.Exists {
		return fmt.Errorf("can't delete not exists object")
	}

	pk, err := obj.packPk()
	if err != nil {
		metricErrCnt.Inc(ctx, "delete_pack", 1)
		return fmt.Errorf("error delete: %w", err)
	}

	w := octopus.PackDelete(namespace, pk)
	log.Printf("Delete packed tuple: '%X'\n", w)

	connection, err := box(ctx, 0, activerecord.MasterInstanceType)
	if err != nil {
		metricErrCnt.Inc(ctx, "delete_preparebox", 1)
		logger.Error(ctx, "Boolindexed", obj.PrimaryString(), fmt.Sprintf("Error get box '%s'", err))

		return err
	}

	respBytes, errCall := connection.Call(ctx, octopus.RequestTypeDelete, w)
	if errCall != nil {
		metricErrCnt.Inc(ctx, "delete_box", 1)
		logger.Error(ctx, "Boolindexed", obj.PrimaryString(), "Error delete from box", errCall, connection.Info())

		return errCall
	}

	metricTimer.Timing(ctx, "delete_box")

	logger.Debug(ctx, "Boolindexed", obj.PrimaryString(), fmt.Sprintf("Response from box '% X'", respBytes))

	_, err = octopus.ProcessResp(respBytes, octopus.NeedRespFlag|octopus.UniqRespFlag)
	if err != nil {
		metricErrCnt.Inc(ctx, "delete_resp", 1)
		logger.Error(ctx, "Boolindexed", obj.PrimaryString(), "Error parse response: ", err)

		return err
	}

	metricStatCnt.Inc(ctx, "delete_success", 1)

	obj.BaseField.Exists = false
	obj.BaseField.UpdateOps = []octopus.Ops{}

	logger.Debug(ctx, "Boolindexed", obj.PrimaryString(), "Success delete")

	metricTimer.Finish(ctx, "delete")

	return nil
}

func (obj *Boolindexed) Update(ctx context.Context) error {
	logger := activerecord.Logger()
	metricTimer := activerecord.Metric().Timer("octopus", "Boolindexed")
	metricStatCnt := activerecord.Metric().StatCount("octopus", "Boolindexed")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "Boolindexed")

	metricStatCnt.Inc(ctx, "update_request", 1)

	if !obj.BaseField.Exists {
		metricErrCnt.Inc(ctx, "update_notexists", 1)
		return fmt.Errorf("can't update not exists object")
	}

	if obj.BaseField.Repaired {
		metricStatCnt.Inc(ctx, "update_repaired", 1)
		logger.Debug(ctx, "", obj.PrimaryString(), "Flag 'Repaired' is true! Insert instead Update")

		return obj.Replace(ctx)
	}

	if len(obj.BaseField.UpdateOps) == 0 {
		metricStatCnt.Inc(ctx, "update_empty", 1)
		logger.Debug(ctx, "", obj.PrimaryString(), "Empty update")

		return nil
	}

	pk, err := obj.packPk()
	if err != nil {
		metricErrCnt.Inc(ctx, "update_packpk", 1)
		return fmt.Errorf("error update: %w", err)
	}

	w := octopus.PackUpdate(namespace, pk, obj.BaseField.UpdateOps)

	log.Printf("Update packed tuple: '%X'\n", w)

	connection, err := box(ctx, 0, activerecord.MasterInstanceType)
	if err != nil {
		metricErrCnt.Inc(ctx, "update_preparebox", 1)
		logger.Error(ctx, "Boolindexed", obj.PrimaryString(), fmt.Sprintf("Error get box '%s'", err))
		return err
	}

	respBytes, errCall := connection.Call(ctx, octopus.RequestTypeUpdate, w)
	if errCall != nil {
		metricErrCnt.Inc(ctx, "update_box", 1)
		logger.Error(ctx, "Boolindexed", obj.PrimaryString(), "Error update ia a box", errCall, connection.Info())
		return errCall
	}

	metricTimer.Timing(ctx, "update_box")

	logger.Debug(ctx, "Boolindexed", obj.PrimaryString(), fmt.Sprintf("Response from box '%X'", respBytes))

	_, err = octopus.ProcessResp(respBytes, octopus.NeedRespFlag|octopus.UniqRespFlag)
	if err != nil {
		metricErrCnt.Inc(ctx, "update_resp", 1)
		logger.Error(ctx, "Boolindexed", obj.PrimaryString(), "Error parse response: ", err)
		return err
	}

	obj.BaseField.UpdateOps = []octopus.Ops{}

	logger.Debug(ctx, "Boolindexed", obj.PrimaryString(), "Success update")

	metricStatCnt.Inc(ctx, "update_success", 1)
	metricTimer.Finish(ctx, "update")

	return nil
}

func (obj *Boolindexed) Insert(ctx context.Context) error {
	metricStatCnt := activerecord.Metric().StatCount("octopus", "Boolindexed")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "Boolindexed")

	metricStatCnt.Inc(ctx, "insert_request", 1)

	if obj.BaseField.Exists {
		metricErrCnt.Inc(ctx, "insert_exists", 1)
		return fmt.Errorf("can't insert already exists object")
	}

	err := obj.insertReplace(ctx, octopus.InsertModeInsert)

	if err == nil {
		metricStatCnt.Inc(ctx, "insert_success", 1)
	}

	return err
}

func (obj *Boolindexed) Replace(ctx context.Context) error {
	metricStatCnt := activerecord.Metric().StatCount("octopus", "Boolindexed")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "Boolindexed")

	metricStatCnt.Inc(ctx, "replace_request", 1)

	if !obj.BaseField.Exists {
		metricErrCnt.Inc(ctx, "replace_notexists", 1)
		return fmt.Errorf("can't replace not exists object")
	}

	err := obj.insertReplace(ctx, octopus.InsertModeReplace)

	if err == nil {
		metricStatCnt.Inc(ctx, "replace_success", 1)
	}

	return err
}

func (obj *Boolindexed) InsertOrReplace(ctx context.Context) error {
	metricStatCnt := activerecord.Metric().StatCount("octopus", "Boolindexed")

	metricStatCnt.Inc(ctx, "insertorreplace_request", 1)

	err := obj.insertReplace(ctx, octopus.InsertModeInserOrReplace)

	if err == nil {
		metricStatCnt.Inc(ctx, "insertorreplace_success", 1)
	}

	return err
}

func (obj *Boolindexed) insertReplace(ctx context.Context, insertMode octopus.InsertMode) error {
	var (
		err   error
		tuple [][]byte
		data  []byte
	)

	metricTimer := activerecord.Metric().Timer("octopus", "Boolindexed")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "Boolindexed")

	data, err = packCode([]byte{}, obj.GetCode())
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_packfield", 1)
		return err
	}

	tuple = append(tuple, data)

	data, err = packInvisible([]byte{}, obj.GetInvisible())
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_packfield", 1)
		return err
	}

	tuple = append(tuple, data)

	metricTimer.Timing(ctx, "insertreplace_packtuple")

	if len(obj.BaseField.ExtraFields) > 0 {
		tuple = append(tuple, obj.BaseField.ExtraFields...)
	}

	w := octopus.PackInsertReplace(namespace, insertMode, tuple)
	logger := activerecord.Logger()

	metricTimer.Timing(ctx, "insertreplace_pack")
	logger.Trace(ctx, "Boolindexed", obj.PrimaryString(), fmt.Sprintf("Insert packed tuple: '%X'", w))

	connection, err := box(ctx, 0, activerecord.MasterInstanceType)
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_preparebox", 1)
		logger.Error(ctx, "Boolindexed", obj.PrimaryString(), fmt.Sprintf("Error get box '%s'", err))

		return err
	}

	respBytes, errCall := connection.Call(ctx, octopus.RequestTypeInsert, w)
	if errCall != nil {
		metricErrCnt.Inc(ctx, "insertreplace_box", 1)
		logger.Error(ctx, "Boolindexed", obj.PrimaryString(), "Error insert into box", errCall, connection.Info())

		return errCall
	}

	metricTimer.Timing(ctx, "insertreplace_box")

	logger.Trace(ctx, "Boolindexed", obj.PrimaryString(), fmt.Sprintf("Response from box '%X'", respBytes))

	tuplesData, err := octopus.ProcessResp(respBytes, octopus.NeedRespFlag|octopus.UniqRespFlag)
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_prespreparebox", 1)
		logger.Error(ctx, "Boolindexed", obj.PrimaryString(), "Error parse response: ", err)

		return err
	}

	_, err = NewFromBox(ctx, tuplesData)
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_obj", 1)
		logger.Error(ctx, "Boolindexed", obj.PrimaryString(), "Error in response: ", err)

		return err
	}

	obj.BaseField.Exists = true
	obj.BaseField.UpdateOps = []octopus.Ops{}
	obj.BaseField.Repaired = false

	logger.Debug(ctx, "Boolindexed", obj.PrimaryString(), "Success insert")

	metricTimer.Finish(ctx, "insertreplace")

	return nil
}
