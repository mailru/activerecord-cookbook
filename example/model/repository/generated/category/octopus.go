// Code generated by argen. DO NOT EDIT.
// This code was generated from a template.
//
// Manual changes to this file may cause unexpected behavior in your application.
// Manual changes to this file will be overwritten if the code is regenerated.
//
// Generate info: argen@v1.11.0-b (Commit: 6934fae2)
package category

import (
	"bytes"
	"context"
	"fmt"

	"github.com/mailru/activerecord/pkg/activerecord"
	"github.com/mailru/activerecord/pkg/iproto/iproto"
	"github.com/mailru/activerecord/pkg/octopus"
)

// proc struct
type Category struct {
	params   CategoryParams
	fieldAll int
}

type CategoryList []*Category

const (
	procName     string = "quantityOfCategories"
	cntOutFields uint32 = 1
)

func (obj *Category) GetAll() int {
	return obj.fieldAll
}

type CategoryParams struct {
}

func (obj *Category) GetParams() CategoryParams {
	return obj.params
}

func (obj *Category) setParams(params CategoryParams) error {
	obj.params = params

	return nil
}

func (obj CategoryParams) PK() string {
	return fmt.Sprint()
}

func Call(ctx context.Context) (*Category, error) {
	return call(ctx, activerecord.ReplicaOrMasterInstanceType)
}

func CallOnMaster(ctx context.Context) (*Category, error) {
	return call(ctx, activerecord.MasterInstanceType)
}

func call(ctx context.Context, instanceType activerecord.ShardInstanceType) (*Category, error) {
	logger := activerecord.Logger()
	ctx = logger.SetLoggerValueToContext(ctx, map[string]interface{}{"LuaProc": procName})
	metricTimer := activerecord.Metric().Timer("octopus", "Category")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "Category")

	metricTimer.Timing(ctx, "call_proc")

	connection, err := octopus.Box(ctx, 0, instanceType, "arcfg", nil)
	if err != nil {
		metricErrCnt.Inc(ctx, "call_proc_preparebox", 1)
		logger.Error(ctx, fmt.Sprintf("Error get box '%s'", err))

		return nil, err
	}

	var args []string

	td, err := octopus.CallLua(ctx, connection, procName, args...)
	if err != nil {
		metricErrCnt.Inc(ctx, "call_proc", 1)
		return nil, fmt.Errorf("call lua procedure %s: %w", procName, err)
	}

	if len(td) != 1 {
		return nil, fmt.Errorf("invalid response len from lua call: %d. Only one tuple supported", len(td))
	}

	ret, err := TupleToStruct(ctx, td[0])
	if err != nil {
		metricErrCnt.Inc(ctx, "call_proc_preparebox", 1)
		logger.Error(ctx, "Error in response: ", err)

		return nil, err
	}

	metricTimer.Finish(ctx, "call_proc")

	activerecord.Logger().CollectQueries(ctx, CallMockerLogger(CategoryList([]*Category{ret})))

	return ret, nil
}

func TupleToStruct(ctx context.Context, tuple octopus.TupleData) (*Category, error) {
	if tuple.Cnt < cntOutFields {
		return nil, fmt.Errorf("not enought selected fields %d in response tuple: %d but expected %d fields", tuple.Cnt, tuple.Cnt, cntOutFields)
	}

	np := Category{}

	valAll, err := UnpackAll(bytes.NewReader(tuple.Data[0]))
	if err != nil {
		return nil, err
	}

	np.fieldAll = valAll

	return &np, nil
}

func (obj *Category) SetAll(All int) error {
	obj.fieldAll = All

	return nil
}

func UnpackAll(r *bytes.Reader) (ret int, errRet error) {
	var All uint32

	err := iproto.UnpackUint32(r, &All, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field All in tuple: '%w'", err)
		return
	}

	bvar := int(All)

	svar := bvar

	return svar, nil
}

func packAll(w []byte, All int) ([]byte, error) {
	pvar := uint32(All)

	return iproto.PackUint32(w, pvar, iproto.ModeDefault), nil
}

// end proc struct

func New(ctx context.Context) *Category {
	newObj := Category{}
	return &newObj
}

// end indexes
